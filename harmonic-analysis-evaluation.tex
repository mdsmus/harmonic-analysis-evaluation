\documentclass{article}
\usepackage{ismir}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{url}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
%\usepackage[htt]{hyphenat}
\usepackage{times}
\usepackage{color}
\usepackage[displaymath,textmath,sections,graphics,floats,auctex]{preview}

\newcounter{notecounter}

\newcommand{\note}[1]{
  \addtocounter{notecounter}{1}
  \textcolor{red}{[note \arabic{notecounter}: #1]}
}
\newcommand{\comment}[1]{}

\title{An evaluation of some heuristic and machine learning algorithms for
  symbolic chord labeling}
\oneauthor {}{}
%% Teoricamente é para não botar o nome do autor no artigo, por causa
%% do processo de revisão.

\PreviewEnvironment{itemize}
\PreviewEnvironment{enumerate}


\begin{document}
\graphicspath{{figs/}{data/}}
\maketitle

\begin{abstract}

  Chord labeling is an important part of harmonic analysis. Many
  algorithms have been proposed for it, but there is no objective
  comparison of their main merits and flaws. Here we present such an
  evaluation, comparing Pardo and Birmingham's and Tsui's algorithms
  and evaluating two new proposals: a k-nearest-neighbors and a
  decision tree classifiers.
  
  Our evaluation methodology tries to be as precise as possible in
  enumerating the errors made by each algorithm. We split the overall
  accuracy in precision and recall, and note which chord types are
  most often mistaken by others. This highlights the difficult areas
  and suggest, for example, how is it better to increment our training
  corpus. The evaluation is performed on Bach chorales.
  
  We find that Tsui's neural network classifier without contextual
  information is the best labeler for all chord modes in our corpus,
  and enhancing it with the surrounding context is the best way of
  incorporating contextual information in the decision process. Pardo
  and Birmingham's algorithm has a very good recall, but a bad
  precision, probably due to its ignorance of non-chord tones, and is
  outperformed by the k-nearest-neighbors classifier, also a pattern
  matcher, The decision tree's performance in unremarkable.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

Chord labeling consists in assigning a name to a set of notes. The
process involves dividing a musical score in symbolic format in
different sonorities, deciding which notes in a sonority is part of a
chord, naming the sonorities with symbols like E$\flat$ or
A$\sharp$7M, and eventually assigning tonal meaning to the sonority
with roman numerals or function names.

The problem of automatic chord labeling of symbolic scores has been
approached from many directions since the sixties. First, Winograd
\cite{winograd68:linguistics} and Ulrich \cite{ulrich77:analysis}
developed backtracking parsers based of formal grammars and
productions. After a hiatus they were followed by Maxwell's
\cite{maxwell92:expert} rule-based expert system and Temperley and
Sleator's preference-rule Melisma system
\cite{temperley.ea99:modeling}. By the end of the nineties Pardo and
Birmingham's HarmAn \cite{barthelemy.ea01:figured}, Barthelemy and
Bonardi's algorithm \cite{pardo.ea02:algorithms}, and Taube's
workbench \cite{taube99:automatic} were built, all using
pattern-matching as their core chord-finding method. Parallel to these
are Tsui's neural network algorithm \cite{tsui02:harmonic}, Temperley's
bayesian approach \cite{temperley04:bayesian}, and Raphael and
Stoddard's hidden Markov model \cite{raphael.ea03:harmonic}. Recently,
Illescas et al. designed a mixed system, based on rules and search
through a graph of possible solutions \cite{illescas.ea07:harmonic}.

Most of these techniques and methods were not described rigorously,
and very little source code is avaliable for testing, which is a
problem since some articles, most notably Barthelemy and Bonardi
\cite{pardo.ea02:algorithms} and Temperley and Sleator
\cite{temperley.ea99:modeling}, don't provide enough information to
reproduce their results reliably. Every benchmark found in literature
\cite{pardo.ea00:automated, pardo.ea02:algorithms, tsui02:harmonic,
  taube99:automatic, illescas.ea07:harmonic} is based only on published
examples, and this difficults a thorough statistical evaluation of the
main merits and flaws of each technique.

In this paper we present an evaluation of Pardo and Birmingham's and
Tsui's algorithms, together with two original algorithms we propose.
First, in section \ref{sec:methodology} we discuss our evaluation
methodology. In section \ref{sec:algorithms} we present Pardo et al's
HarmAn, Tsui's artificial neural networks, our decision trees and our
k-nearest-neighbors method. We compare their overall performance in
section \ref{sec:discussion} and state our case in section
\ref{sec:conclusions}.

\begin{table}
\centering
\begin{tabular}{l|l}
chord & meaning \\ \hline
    M & major chord \\
   M7 & major chord, minor seventh \\
  M7+ & major chord, major seventh \\
    m & minor chord \\
   m7 & minor chord, minor seventh \\
    ° & diminished triad \\
   °7 & fully diminished chord \\
   ø7 & half-diminished chord \\
  aug & augmented chord \\
  inc & incomplete chord \\
 aug6 & augmented sixth chord \\
  nct & non-chord tone \\
  avg & average over all chord types \\
\end{tabular}
\caption{Labels used in this article}
\label{tab:legenda}
\end{table}

\section{Methodology}
\label{sec:methodology}

\begin{table*}
\centering
\begin{tabular}{l||r|r|r|r|r|r|r|r|r|r|r|r|r}
      &     M &    M7 &   M7+ &     m &    m7 &    ° &   °7 &   ø7 &   aug &   inc &  aug6 &   nct \\  \hline \hline
    M & $ 774 $ & $     $ & $     $ & $   1 $ & $   1 $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $  34 $ \\ \hline
   M7 & $     $ & $ 176 $ & $     $ & $   2 $ & $     $ & $   7 $ & $     $ & $     $ & $     $ & $     $ & $     $ & $  12 $ \\ \hline
  M7+ & $  11 $ & $     $ & $   1 $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $  38 $ \\ \hline
    m & $   3 $ & $     $ & $   1 $ & $ 313 $ & $   4 $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $   7 $ \\ \hline
   m7 & $   5 $ & $   4 $ & $     $ & $     $ & $ 106 $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $   5 $ \\ \hline
   ° & $     $ & $     $ & $     $ & $     $ & $     $ & $ 100 $ & $   2 $ & $     $ & $     $ & $     $ & $     $ & $   2 $ \\ \hline
  °7 & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $  30 $ & $     $ & $     $ & $     $ & $     $ & $     $ \\ \hline
  ø7 & $     $ & $     $ & $     $ & $   1 $ & $   6 $ & $     $ & $     $ & $  44 $ & $     $ & $     $ & $     $ & $     $ \\ \hline
  aug & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $   4 $ \\ \hline
  inc & $   5 $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $   4 $ \\ \hline
 aug6 & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $   3 $ & $     $ \\ \hline
  nct & $  27 $ & $  21 $ & $     $ & $  40 $ & $  44 $ & $  14 $ & $   4 $ & $  13 $ & $     $ & $     $ & $     $ & $ 304 $ \\ \hline
\end{tabular}
\caption{Classifications made by our best algorithm, \texttt{ES-net}. The rows represent
  the expected answers while the columns are the returned
  results. Note that the matrix is not symmetric.}
\label{tab:erros-es-net}
\end{table*}



Evaluating the performance of a chord labeling algorithm with a simple
metric such as the ratio of correct classifications might be useful to
give an idea of how well it generally works, but may hides errors in
analyzing uncommon chord types. Some chord types are often mistaken
for others, as can be seen in table \ref{tab:erros-es-net}, and some
algorithms tend to ignore less frequent chord modes, as can be seen in
table \ref{tab:erros-es-pb}.

To precisely detect each of the possible errors we propose a different
evaluation methodology. We will evaluate our algorithms by their
precision and recall with respect to each chord mode, thereby showing
the weaknesses of each algorithm.

The decision of evaluating chord labeling performance using precision
and recall is a bit unusual, and deserves justification. Here, we
assume that the aim of our algorithms is to retrieve correctly each
sonority belonging to a certain chord type from a song. We also treat
the detection of each chord type separately. Hence, every time a
diminished chord is misclassified as a non chord tone, for example,
the recall of diminished chords gets smaller, while the precision of
the non-chord tones get smaller. Having this data allows us to detect
biases in the algorithms, and highlight some of their properties. For
example, Pardo and Birmingham's algorithm, as seen in section
\ref{sec:discussion}, has a high recall and a small precision, while
the machine learning algorithms have mostly equivalent precision and
recall.

We will perform this evaluation on a corpus of 18 Bach chorales from
the Riemenschneider edition \cite{bach41:371}, consisting of the
chorales numbered 7, 8, 10, 12, 14, 17, 18, 19, 20, 21, 22, 23, 24,
25, 26, 140, 162, and 340. We wrote answer sheets for each chorale
with the chord label for each segment. With these answer sheets, our
system is able to automatically compare the results of each algorithm
with the correct result as analyzed by musicians. The code and data
used in this evaluation are available, together with instructions to
reproduce our analysis, at \url{http://removed-for-anonymity}.

\section{Algorithms}
\label{sec:algorithms}

\begin{table*}
\centering
\begin{tabular}{l||r|r|r|r|r|r|r|r|r|r|r|r|r}
      &     M &    M7 &   M7+ &     m &    m7 &    ° &   °7 &   ø7 &   aug &   inc &  aug6 &   nct \\  \hline \hline
    M & $ 774 $ & $     $ & $   3 $ & $   5 $ & $     $ & $     $ & $     $ & $   3 $ & $     $ & $  55 $ & $     $ & $     $ \\ \hline
   M7 & $     $ & $ 180 $ & $   2 $ & $   5 $ & $     $ & $   7 $ & $     $ & $     $ & $     $ & $   4 $ & $     $ & $     $ \\ \hline
  M7+ & $     $ & $     $ & $  27 $ & $   4 $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ \\ \hline
    m & $   3 $ & $     $ & $   1 $ & $ 317 $ & $   2 $ & $     $ & $     $ & $   2 $ & $     $ & $   3 $ & $     $ & $     $ \\ \hline
   m7 & $   5 $ & $   4 $ & $     $ & $   5 $ & $  88 $ & $     $ & $     $ & $  39 $ & $     $ & $     $ & $     $ & $     $ \\ \hline
   ° & $   2 $ & $     $ & $     $ & $     $ & $     $ & $ 101 $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ \\ \hline
  °7 & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $  30 $ & $     $ & $     $ & $     $ & $     $ & $     $ \\ \hline
  ø7 & $     $ & $     $ & $     $ & $   1 $ & $     $ & $     $ & $     $ & $  46 $ & $     $ & $     $ & $   2 $ & $     $ \\ \hline
  aug & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $   2 $ & $     $ & $     $ & $     $ \\ \hline
  inc & $   1 $ & $   4 $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $   2 $ & $     $ & $     $ \\ \hline
 aug6 & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $     $ & $   3 $ & $     $ \\ \hline
  nct & $ 163 $ & $ 115 $ & $  91 $ & $ 133 $ & $  28 $ & $  34 $ & $   2 $ & $  55 $ & $  10 $ & $ 138 $ & $   4 $ & $     $ \\ \hline
\end{tabular}

\caption{Classifications made by the extended Pardo and Birmingham's algorithm. The rows represent
  the expected answers while the columns are the returned
  results. Note that many chord types are ignored.}
\label{tab:erros-es-pb}
\end{table*}

Chord labeling is a classification problem, consisting of labeling
each sonority (or sequence of sonorities) in a score with a chord
type. Most classification algorithms operate on a set of features,
that are previously extracted from the data. This is done mainly to
remove irregularities in the original inputs, reduce the
dimensionality (thereby making a problem more tractable) of the
problem, and remove noise. Each classification algorithm we present
operates on a distinct set of features, mostly derived from the
pitches of the notes. Metrical information is ignored, for now.

In this section we present Pardo and Birmingham's algorithm and a few
machine learning techniques. The machine learning algorithms were
trained on the chorales numbered 1, 2, 3, 4, 5, and 6 of the
Riemenschneider edition and on some textbook examples of augmented
sixths, augmented chords, and major chords with major sevenths
extracted from Robert Gauldin \cite{gauldin05:harmonic} and Reginald
Morris \cite{morris33:figured}. These chorales were not used in our
subsequent evaluation.

\subsection{Pardo and Birmingham's algorithm}
\label{sec:pardo}


Pardo and Birmingham \cite{barthelemy.ea01:figured} describe a
pattern-matching algorithm for chordal analysis based on templates.
The article enumerates six templates, and the algorithm searches
across the piece for the labeling that better matches the notes found.
When a tie happens between two templates, a tie-breaking heuristic is
used (one such heuristic is ``prefer more common labelings''). In
practice, most of the non-trivial decisions made by this algorithm are
codified as tie-breaking rules, and this approach doesn't scale
well. Raphael and Stoddard describe problems common to rule based
systems \cite{raphael.ea03:harmonic}, and we have found that most of
them also apply to Pardo and Birmingham's algorithm.

Some limitations are obvious from the article. The algorithm, for
example, has no notion of a minor chord with a minor seventh, or an
augmented chord, or a chord without a third. Also, since their system
ignores enharmonic information some fine distinctions are lost, and a
german augmented sixth is shown being classified erroneously as a
dominant seventh. We have then extended the algorithm presented in the
article by incorporating more chord templates (giving a total of ten)
and enabling it to distinguish enharmonic tones, which improved the
recall of fully diminished chords and the precision in recognizing
major chords, as seen in section \ref{sec:discussion}. We have also
added inversion detection. The original algorithm is referred to as
\texttt{s-pb} and our extended version as \texttt{es-pb}.

\subsection{Decision Tree}
\label{sec:tree}

Our decision tree uses the ID3 algorithm \cite{mitchell97:machine}.
Since our decision tree library can't handle numeric attributes well,
we use the four pitch classes of each sonority to be classified as
features . This, unfortunately, makes it impossible for this algorithm
to generalize to musical styles not very similar to a four-part
chorale, although an extension to allow this is planned. This
algorithm is named \texttt{es-tree}. It distinguishes enharmonic notes
but ignores the surrounding context.

\subsection{Artificial Neural Networks}
\label{sec:neural-net}


The artificial neural networks we used are modeled after Tsui's Root
Network A \cite{tsui02:harmonic}. The main differences are in the
feature extraction process and that we consider chord types other than
major and minor. Tsui uses as features a vector, each position
containing how many times one pitch class sounds in a given
sonority. On training, Tsui's algorithm first transposes each sonority
to the 12 possible pitch classes to ensure that the network is
invariant under transposition. While interesting, this approach
becomes computationally prohibitive if one wants to distinguish
enharmonic notes. Instead, we chose to transpose each sonority so that
it has C as its lowest note. This codification also preserves
transposition invariance and allows a much simpler network structure.

We implemented two neural network algorithms: \texttt{es-net}, that
does not use contextual information, and \texttt{ec-net}, which
does. Both distinguish enharmonic notes.  It should be noted that,
unlike Tsui, our neural networks have an overall worse accuracy as
context is added, as can be seen in section \ref{sec:discussion}. Our
experiments determined that the best amount of contextual information
is the least possible, so \texttt{ec-net} looks only at one preceding
and one following sonority.


\subsection{K-Nearest-Neighbors}
\label{sec:knn}

We implemented a k-neartest-neighbors algorithm because it has good
performance and is easy to implement \cite{fix.ea89:important,
  gomez.ea04:estimating}. The features used in this classifier were the
same as in the neural networks. Our two k-nearest-neighbor algorithms,
\texttt{es-knn} and \texttt{ec-knn}, distinguish enharmonic notes, and
the only difference between them is that \texttt{es-knn} looks at one
sonority at a time, while \texttt{ec-knn} also receives information
from surrounding sonorities as input. Experimentally we have
determined that the best k value is 1, using only the nearest
neighbor, for \texttt{es-knn} and 2 for \texttt{ec-knn}. The
surrounding sonorities in \texttt{ec-knn} are weighted by a factor of
2 times their distance from the current sonority.

\section{Results}
\label{sec:discussion}


Overall, \texttt{es-net} has the best precision, recall, f-measure and
accuracy, as seen in tables \ref{tab:precision}, \ref{tab:recall},
\ref{tab:f-measure}, and \ref{tab:accuracy}. The high performance of
\texttt{ES-knn},as seen in table \ref{tab:f-measure}, suggests that
smarter pattern matching might boost the performance of \texttt{ES-PB}, since
both algorithms work as glorified template matchers. \texttt{s-pb} and
\texttt{es-pb} have very good recall but terrible precision, probably
due to their discarding of non-chord tones, as can be seen in table
\ref{tab:erros-es-pb}.


Diminished chords and
non-chord tones, as seen in table \ref{tab:f-measure}, are not
fundamentally easier to recognize without contextual
information. Augmented chords, on the other hand, appear to require
context to be recognized by machine learning algorithms.


Averaged f-measure over all chord types is, as expected, highly
correlated with overall accuracy, as seen it table \ref{tab:accuracy}.


\begin{table}
  \centering
\begin{tabular}{l|p{0.5cm}p{0.5cm}p{0.5cm}p{0.5cm}p{0.5cm}p{0.5cm}p{0.5cm}p{0.5cm}}
       &      EC-Knn &      EC-net &      ES-Knn &       ES-PB &      ES-net &     ES-tree &        S-PB \\ \hline
   M & $  88.4$ & $  94.4$ & $  95.8$ & $  90.6$ & $  97.7$ & $  89.2$ & $  71.4$ \\
  M7 & $  85.3$ & $  91.0$ & $  89.7$ & $  75.0$ & $  94.1$ & $  82.9$ & $  74.1$ \\
 M7+ & $  50.0$ & $  25.0$ & $ ~~0.0$ & $  38.6$ & $ 100$ & $ ~~0.0$ & $ ~~0.0$ \\
   m & $  82.7$ & $  89.5$ & $  89.4$ & $  83.9$ & $  94.6$ & $  83.8$ & $  83.6$ \\
  m7 & $  65.5$ & $  66.2$ & $  76.9$ & $  86.3$ & $  80.3$ & $  54.8$ & $ ~~0.0$ \\
  ° & $  86.0$ & $  71.0$ & $  90.0$ & $  87.1$ & $  95.2$ & $  70.4$ & $  83.5$ \\
 °7 & $  87.5$ & $  54.5$ & $ 100$ & $  96.8$ & $  90.9$ & $  51.4$ & $ 100$ \\
 ø7 & $  60.6$ & $  50.0$ & $  97.3$ & $  50.0$ & $  89.8$ & $  71.1$ & $  49.5$ \\
 aug & $ ~~0.0$ & $ 100$ & $ ~~0.0$ & $  28.6$ & $ ~~0.0$ & $ ~~0.0$ & $ ~~0.0$ \\
 inc & $ ~~0.0$ & $ ~~0.0$ & $ ~~0.0$ & $ ~~2.5$ & $ ~~0.0$ & $ ~~0.0$ & $ ~~0.0$ \\
aug6 & $  50.0$ & $  12.5$ & $ 100$ & $  50.0$ & $ 100$ & $ ~~0.0$ & $ ~~0.0$ \\
 nct & $  74.1$ & $  76.6$ & $  80.8$ & $ ~~0.0$ & $  88.3$ & $  70.0$ & $ ~~0.0$ \\
\hline avg & $  60.8$ & $  60.9$ & $  68.3$ & $  57.4$ & $  77.6$ & $  47.8$ & $  38.5$ \\
\end{tabular}


  \caption{Precision (\%)}
  \label{tab:precision}
\end{table}

\begin{table}
  \centering
\begin{tabular}{l|p{0.5cm}p{0.5cm}p{0.5cm}p{0.5cm}p{0.5cm}p{0.5cm}p{0.5cm}p{0.5cm}}
       &      EC-Knn &      EC-net &      ES-Knn &       ES-PB &      ES-net &     ES-tree &        S-PB \\ \hline
   M & $  95.2$ & $  97.3$ & $  98.3$ & $  97.2$ & $  98.7$ & $  96.3$ & $  99.7$ \\
  M7 & $  78.4$ & $  87.6$ & $  94.1$ & $  96.3$ & $  95.1$ & $  62.0$ & $  96.8$ \\
 M7+ & $  12.5$ & $ ~~4.5$ & $ ~~0.0$ & $  96.4$ & $ ~~4.5$ & $ ~~0.0$ & $ ~~0.0$ \\
   m & $  87.7$ & $  88.7$ & $  95.9$ & $  98.8$ & $  98.4$ & $  89.3$ & $  98.4$ \\
  m7 & $  66.1$ & $  78.6$ & $  83.0$ & $  77.9$ & $  94.6$ & $  56.8$ & $ ~~0.0$ \\
  ° & $  80.0$ & $  71.7$ & $  97.1$ & $  99.0$ & $  98.0$ & $  57.0$ & $  99.0$ \\
 °7 & $  70.0$ & $  20.0$ & $  70.0$ & $ 100$ & $ 100$ & $  60.0$ & $  86.7$ \\
 ø7 & $  42.6$ & $  21.3$ & $  76.6$ & $  97.9$ & $  93.6$ & $  56.2$ & $ 100$ \\
 aug & $ ~~0.0$ & $  50.0$ & $ ~~0.0$ & $ 100$ & $ ~~0.0$ & $ ~~0.0$ & $ ~~0.0$ \\
 inc & $ ~~0.0$ & $ ~~0.0$ & $ ~~0.0$ & $  50.0$ & $ ~~0.0$ & $ ~~0.0$ & $ ~~0.0$ \\
aug6 & $  66.7$ & $  33.3$ & $ 100$ & $ 100$ & $ 100$ & $ ~~0.0$ & $ ~~0.0$ \\
 nct & $  69.5$ & $  81.9$ & $  75.1$ & $ ~~0.0$ & $  82.3$ & $  69.8$ & $ ~~0.0$ \\
\hline avg & $  55.7$ & $  52.9$ & $  65.8$ & $  84.5$ & $  72.1$ & $  45.6$ & $  48.4$ \\
\end{tabular}


  \caption{Recall (\%)}
  \label{tab:recall}
\end{table}


\begin{table}
  \centering
\begin{tabular}{l|p{0.5cm}p{0.5cm}p{0.5cm}p{0.5cm}p{0.5cm}p{0.5cm}p{0.5cm}p{0.5cm}}
       &      EC-Knn &      EC-net &      ES-Knn &       ES-PB &      ES-net &     ES-tree &        S-PB \\ \hline
   M & $  91.7$ & $  95.8$ & $  97.0$ & $  93.8$ & $  98.2$ & $  92.6$ & $  83.2$ \\
  M7 & $  81.7$ & $  89.3$ & $  91.8$ & $  84.3$ & $  94.6$ & $  70.9$ & $  83.9$ \\
 M7+ & $  20.0$ & $ ~~7.6$ & $ ~~0.0$ & $  55.1$ & $ ~~8.6$ & $ ~~0.0$ & $ ~~0.0$ \\
   m & $  85.1$ & $  89.1$ & $  92.5$ & $  90.7$ & $  96.5$ & $  86.5$ & $  90.4$ \\
  m7 & $  65.8$ & $  71.9$ & $  79.8$ & $  81.9$ & $  86.9$ & $  55.8$ & $ ~~0.0$ \\
  ° & $  82.9$ & $  71.3$ & $  93.4$ & $  92.7$ & $  96.6$ & $  63.0$ & $  90.6$ \\
 °7 & $  77.8$ & $  29.3$ & $  82.4$ & $  98.4$ & $  95.2$ & $  55.4$ & $  92.9$ \\
 ø7 & $  50.0$ & $  29.9$ & $  85.7$ & $  66.2$ & $  91.7$ & $  62.8$ & $  66.2$ \\
 aug & $ ~~0.0$ & $  66.7$ & $ ~~0.0$ & $  44.5$ & $ ~~0.0$ & $ ~~0.0$ & $ ~~0.0$ \\
 inc & $ ~~0.0$ & $ ~~0.0$ & $ ~~0.0$ & $ ~~4.8$ & $ ~~0.0$ & $ ~~0.0$ & $ ~~0.0$ \\
aug6 & $  57.2$ & $  18.2$ & $ 100$ & $  66.7$ & $ 100$ & $ ~~0.0$ & $ ~~0.0$ \\
 nct & $  71.7$ & $  79.2$ & $  77.8$ & $ ~~0.0$ & $  85.2$ & $  69.9$ & $ ~~0.0$ \\
\hline avg & $  57.0$ & $  54.0$ & $  66.7$ & $  64.9$ & $  71.1$ & $  46.4$ & $  42.3$ \\
\end{tabular}


  \caption{F-measure (\%)}
  \label{tab:f-measure}
\end{table}



\begin{table}
  \centering
  \begin{tabular}{l|rrr}
       & accuracy& $\sigma$  & f-measure\\
\hline
ES-net &$   93  $&$  3$      &$71.1$ \\
ES-knn &$   90  $&$  4$      &$66.7$ \\
EC-net &$   85  $&$  5$      &$54.0$ \\
EC-knn &$   82  $&$  4$      &$57.0$ \\
ES-pb  &$   80  $&$  5$      &$64.9$ \\
ES-tree&$   79  $&$  7$      &$46.4$ \\
S-pb   &$   68  $&$ 15$      &$42.3$ \\

  \end{tabular}                                                        


  \caption{Overall Accuracy (\%)}
  \label{tab:accuracy}
\end{table}

\section{Conclusions and future work}
\label{sec:conclusions}

We have evaluated algorithms for chord labeling of symbolic scores of
tonal music on a corpus of 40 Bach chorales and have found that an
artificial neural network that does not use contextual information is
the best algorithm evaluated. We have also found that a simple
memory-based classifier can outperform some heuristic algorithms. We
also presented a modification to the algorithm described in
\cite{barthelemy.ea01:figured} that is demonstrably better.

We will continue to reimplement, test, and benchmark algorithms for
automated chord labeling and harmonic analysis, starting with Raphael
and Stoddard's hidden Markov model \cite{raphael.ea03:harmonic} and
Maxwell's expert system \cite{maxwell92:expert}.  We will also extend
our test corpus to incorporate Beethoven sonatas, the Kostka-Payne
corpus \cite{temperley04:bayesian}, Bach partitas, and other
representative tonal pieces. Our aim is to benchmark and study the
whole harmonic analysis process, from pitch spelling to functional and
non-chord tone analysis.

\bibliographystyle{plain}
\bibliography{strings-short,ismir,programs,coding,harmonic-analysis,dont-have,artifical-inteligence,music-harmony-and-theory,licenses,icmc,music-scores}

\end{document}

